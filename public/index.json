[{"content":"Leetcode problem link: Merge Overlapping Intervals Optimised Approach Make copy of the input array (it\u0026rsquo;s a good practice to not update the inputs provided). Sort the copied input based upon the start of each interval. Add the first interval from sorted list to the output. For each element in the sorted list from index 1, if it is able to merge to the last interval in output then merge else add to the output list. Return the output. Time \u0026amp; Space Complexity Time Complexity: O(N)\nSpace Complexity: O(N)\nJava Code class Solution { public int[][] merge(int[][] intervals) { int N = intervals.length; int[][] copyInterval = intervals.clone(); ArrayList\u0026lt;int[]\u0026gt; output = new ArrayList\u0026lt;\u0026gt;(); Arrays.sort(copyInterval, (firstInterval, secondInterval) -\u0026gt; Integer.compare(firstInterval[0], secondInterval[0])); output.add(copyInterval[0]); for (int i = 1; i \u0026lt; N; i++) { int[] firstInterval = output.get(output.size() - 1); int[] secondInterval = copyInterval[i]; if (secondInterval[0] \u0026lt;= firstInterval[1]) { firstInterval[0] = Math.min(firstInterval[0], secondInterval[0]); firstInterval[1] = Math.max(firstInterval[1], secondInterval[1]); } else { output.add(secondInterval); } } return output.toArray(new int[output.size()][]); } } ","permalink":"https://coderhyno.com/blog/dsa/merge_overlapping_intervals/","summary":"Leetcode problem link: Merge Overlapping Intervals Optimised Approach Make copy of the input array (it\u0026rsquo;s a good practice to not update the inputs provided). Sort the copied input based upon the start of each interval. Add the first interval from sorted list to the output. For each element in the sorted list from index 1, if it is able to merge to the last interval in output then merge else add to the output list.","title":"Merge Overlapping Intervals"}]